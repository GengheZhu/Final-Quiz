/*
Class includes sorts WITH STEP COUNTERS ADDED IN
    * 
    * 
    * 
    * 
    *                   100 Integers        200 Integers        400 Integers        800 Integers
    * Bubble            23942               95412               399092               1604124
    *
    * Selection         15386               60786               241265               963596
    * 
    * Insertion         7674                30584               113073               480263
    * 
    * Although all of these methods can sort integers, some methods are better to be used than others. 
    * Through the outcome of this lab, I can conlude that insertion sort is generally the most efficient sorting method.
    * Bubble sort is generally the least efficient method. 
    */

import java.util.ArrayList;
public class ShawnKeswaniPeriod6
{
    private long steps; 
        public void bubbleSort(ArrayList <Comparable> list){
      steps = 0;
      for (int outer = 0; outer < list.size() - 1; outer++){
        for (int inner = 0; inner < list.size()-outer-1; inner++){
            steps += 3;//count one compare and 2 gets
            if (list.get(inner).compareTo(list.get(inner + 1)) > 0){
               steps += 4;//count 2 gets and 2 sets
               Comparable temp = list.get(inner);
               list.set(inner,list.get(inner + 1));
               list.set(inner + 1,temp);
            }
        }
      }
    }


    public void selectionSort(ArrayList <Comparable> list){
        int min;
        Comparable temp;
        steps = 0;
        for (int outer = 0; outer < list.size() - 1; outer++){
            min = outer;
            for (int inner = outer + 1; inner < list.size(); inner++){
                steps+= 3; //counts two gets and a comparison
                if (list.get(inner).compareTo(list.get(min))<0) {
                    min = inner; // a new smallest item is found
                }
            }
            //swap list[outer] & list[min]
            steps+= 4; //counts 2 gets and 2 sets 
            temp = list.get(outer);
            list.set(outer, list.get(min));
            list.set(min, temp);
        }
        System.out.println();
        System.out.println("Selection Sort");
        System.out.println();
    }
    
    public void insertionSort(ArrayList <Comparable> list){
        //replace these lines with your code
        steps = 0;
          for (int outer = 1; outer < list.size(); outer++){
            int position = outer;
            Comparable key = list.get(position);
            // Shift larger values to the right
            while (position > 0 && list.get(position - 1).compareTo(key) > 0){
              list.set(position, list.get(position - 1));
              position--;
              steps++;
            }
            list.set(position, key);
          }
        System.out.println();
        System.out.println("Insertion Sort");
        System.out.println();
    }

   public void mergeSort(ArrayList <Comparable> a, int first, int last){
    //replace these lines with your code
    System.out.println();
    System.out.println("Merge Sort");
    System.out.println();
   }

   public long getStepCount(){
       return steps;
   }
   
    public void setStepCount(long stepCount){
        steps = stepCount;
    }
}
